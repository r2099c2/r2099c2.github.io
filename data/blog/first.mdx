---
title: 第1期：利用 github-pages 搭建个人博客
slug: 2024-07-23-001
date: '2024-07-23'
draft: true
tags: ['github', 'guide']
---

# 利用 github-pages 搭建个人博客

## 1. 利用现成的脚手架

如果你只是为了搭建个博客，最简单的方案是直接用一个免费的模板，然后直接部署到 github-pages、vercel 或者自己的云服务上。

例如，我正在使用的是 https://github.com/timlrx/tailwind-nextjs-starter-blog 欢迎使用，并记得去给作者 star 或赞助。

你只需要对这个博客模板进行一些小修改即可使用，例如替换名称、为 Github Actions 配置修改下自动部署规则等。

## 2. 利用 GitHub Pages 部署项目。

`GitHub Pages` 提供了静态页面的部署能力，很适合我们这样的博客场景，另一个是 `vercel` 会更强大一些，免费的额度用来部署一般的站点都够了，不局限是静态博客，甚至可以搭建数据库、后台服务等。

上面介绍的这个`tailwind nextJs`模板默认就是支持 `vercel` 部署的。

官方文档: https://docs.github.com/zh/pages/quickstart

注意: 仓库名必须是 `username.github.io`，其中 `username` 是你的 github 用户名。否则无法使用 github-pages 服务。

创建完成后其实在对应的 `https://<yourUserName>.github.io` 就可以访问了。此时只是一个空白页面。

简单使用的话，可以放 `html` 或者 `markdown` 文件。

如果是用的模板，则可以直接将模板放到仓库中，然后修改提交。

## 3. 利用 Actions 自动部署 github-pages

官方文档：https://docs.github.com/zh/actions/guides/deploying-to-github-pages

### 3.1 创建 Action 流程配置文件。

注意：只有 `public`的仓库 或者付费才能选择。

#### 手动创建。

可以选择直接手动创建一个 `yml` 文件，然后提交到 `.github/workflows` 目录下。

#### 自动创建

在 `git repo` 中选择 `Settings` -> `Pages` -> `Build and deployment`

切换 `source` 到 `Github Actions`。

此时`github`会根据你的仓库语言推荐一个打包流程，会自动创建 `.github/workflows` 目录，并创建一个 `yml` 文件。

例如我们是 `next.js` 项目，那么会创建一个 `node.js.yml` 文件，点开后选择确认即可创建。

此时，`Actions` 标签就可以使用了。

当然，我们需要对这个文件进行一些调整，最简单的方案就是去掉 `Setup Pages` 部分，因为这部分会尝试将项目项目作为静态文件打包，而我们需要通过 `node` 方式打包。

去掉后就可以正常执行了，每次 `push` 到 `main` 分支就会自动出发 `Action`，为了不浪费资源，建议在其他分支搞完合并过去。

## 2. 创建一个 next.js 项目，并增强相关能力

官方文档：https://nextjs.org/docs/getting-started/installation

参照官方文档，创建一个 next.js 项目即可，建议使用最新版本的 `App Router, Typescripts` 等相关技术。

### 2.1 使用 MDX 能力

什么是 MDX:
https://mdxjs.com/

简单来说就是可以让你在 markdown 文件中写 JSX 代码。

安装依赖：

```bash
npm install @next/mdx @mdx-js/loader @mdx-js/react
```

然后配置:

```javascript
// next.config.js 配置：
// 允许 nextJs 识别 mdx 并作为组件处理
import nextMdx from '@next/mdx'

const withMdx = nextMdx({
  // By default only the `.mdx` extension is supported.
  extension: /\.mdx?$/,
  options: {
    /* otherOptions… */
  },
})

/** @type {import('next').NextConfig} */
const nextConfig = withMdx({
  // Support MDX files as pages:
  pageExtensions: ['md', 'mdx', 'tsx', 'ts', 'jsx', 'js'],
})

export default nextConfig
```

### 2.2 利用 gray-matter 解析 markdown 文件的配置，增强能力

https://github.com/jonschlinkert/gray-matter

gray-matter 能做什么?

将：

```mdx
---
title: Hello
slug: home
---

<h1>Hello world!</h1>
```

解析成

```javascript
{
  data: {
    title: 'Hello',
    slug: 'home'
  },
  content: '<h1>Hello world!</h1>'
}
```

使用方式，安装依赖：

```bash
npm install gray-matter
```

````
```
import matter from 'gray-matter';

const { data, content } = matter(markdownString);
```
````

## 3. 首页开发

1. 我们要做的事情是，将 `mdx` 的内容统一放到 `content` 文件夹下。
2. 通过 `gray-matter` 解析 `mdx` 文件，获取 `title` 和 `slug`。
3. 将内容部分展示到首页。

### 3.1 读取文件，并处理

我们在统一的函数中做这个处理。

示例写法：

```ts
import path from 'path'
import fs from 'fs'
import matter from 'gray-matter'
import dayjs from 'dayjs'
import { Post, PostByMonth } from '@/types/post'

/**
 * 从 content 目录获取所有文章，并组合数据
 */
export const getPosts = async () => {
  const postDirectory = path.join(process.cwd(), 'content')
  const filenames = (await fs.promises.readdir(postDirectory)).reverse()

  const posts: Post[] = await Promise.all(
    filenames.map(async (filename) => {
      const filePath = path.join(postDirectory, filename)
      const fileContent = await fs.promises.readFile(filePath, 'utf8')

      const { data, content } = matter(fileContent)

      const month = dayjs(data.date).format('YYYY-MM-DD').slice(0, 7)

      return {
        month,
        filePath,
        data,
        content,
      }
    })
  )

  const postsByMonth = posts.reduce((acc: PostByMonth, post: Post) => {
    const month = dayjs(post.data.date).format('YYYY-MM-DD').slice(0, 7)
    if (!acc[month]) {
      acc[month] = []
    }
    acc[month].push(post)
    return acc
  }, {})

  return {
    posts,
    postsByMonth,
  }
}
```

### 3.2 首页展示

在首页我们可以读取这里的数据，按照想要的格式进行展示，例如一个列表。

仅作示例，NavList TimeLine 自行实现。

```tsx
export default async function Home() {
  const { posts, postsByMonth } = await getPosts()

  return (
    <>
      <main className="flex w-full flex-row pt-12">
        <div className="hidden pl-6 md:block md:w-1/5"></div>
        <div className="w-full px-6 md:w-3/5">
          <NavList posts={posts} />
        </div>
        <div className="hidden justify-end pr-6 text-right md:flex md:w-1/5">
          <TimeLine postsByMonth={postsByMonth} />
        </div>
      </main>
    </>
  )
}
```

## 4. 详情页开发

详情页就是根据 `slug` 去读取对应的 `mdx` 文件，然后展示。

### 4.1 创建动态路由

根据 `nextJs` 的 `Router` 规范，以及在首页 `NavList` 中自行设定的跳转逻辑，我们需要一个 `app/post/[slug]/page.tsx` 文件，来访问`post/[slug]`路由。

### 4.2 MDXRemote 来渲染 MDX 内容

`nextJs` 提供了一个 `MDXRemote` 组件，可以将 `mdx` 文件中的 `jsx` 代码渲染出来。

```tsx
import { MDXRemote } from 'next-mdx-remote/rsc'
import { getPosts } from '@/lib/helper'

export default function PostPage({ params }: { params: { slug: string } }) {
  const { posts } = await getPosts()
  const post = posts.find((post) => post.data.slug === slug)

  return (
    <div className="w-full px-6 md:w-3/5">
      <MDXRemote source={post.content} />
    </div>
  )
}
```

### 4.3 generateStaticParams 生成静态路由参数

在 `nextJs` 中，我们可以通过 `generateStaticParams` 来生成静态路由参数。https://nextjs.org/docs/app/api-reference/functions/generate-static-params

```tsx
export const generateStaticParams = async () => {
  const { posts } = await getPosts()

  return posts.map((post) => ({
    slug: post.data.slug,
  }))
}
```

### 5.3 为 MDXRemote 调整样式

我们用了 `tailwinds.css` 会覆盖原有的样式，同时 `MDXRemote` 支持我们通过 `components` 属性来自定义样式。

```tsx
<MDXRemote source={post.content} components={MDXComponents} />
```

### 或者使用 `contentlayer` 来配置所有的博客内容

参考： https://contentlayer.dev/docs/getting-started-cddd76b7

通过 `content layer` 的 `conentlayer.config.ts` 对于各种数据的配置，可以很方便的配置管理各种数据格式。
